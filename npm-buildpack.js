#!/usr/bin/env node

var request = require('request')
var fs = require('fs')
var after = require('after-all')
var pump = require('pump')
var parallel = require('parallel-transform')
var split = require('split')
var path = require('path')
var ncp = require('ncp')
var mkdirp = require('mkdirp')
var rimraf = require('rimraf')
var minimist = require('minimist')
var proc = require('child_process')
var os = require('os')

var TMP = fs.existsSync('/tmp') ? '/tmp' : os.tmpdir()

var argv = minimist(process.argv, {
  alias: {n:'name', f:'force', i:'install', h:'help'},
  boolean: 'install'
})

if (argv.help || argv.h) {
  console.error(
    'Usage: npm-buildpack [options]\n\n'+
    '  --cache   , -c   to set the cache dir. defaults to /tmp/npm-buildpack\n'+
    '  --force   , -f   do not use the cache when installing\n'+
    '  --name    , -n   set the cache index name. defaults to package.name\n'+
    '  --install , -i   always install node_modules, even if ./node_modules exists\n'
  )
  process.exit(0)
}

var req = function(url) {
  return fs.existsSync(url) ? require(fs.realpathSync(url)) : {}
}

var cache = argv.cache || path.join(TMP, 'npm-buildpack')
var pkg = req(path.join(process.cwd(), 'package.json'))
var tmp = path.join(cache, argv.name || pkg.name)
var old = req(path.join(tmp, 'package.json'))

var localModules = path.join(process.cwd(), 'node_modules')
var cacheModules = path.join(tmp, 'node_modules')

if (argv.force) rimraf.sync(cacheModules)
mkdirp.sync(cacheModules)

if (!argv.install && fs.existsSync(localModules)) return proc.spawn('npm', ['rebuild'], {stdio:'inherit'}).on('exit', process.exit.bind(process))

var onerror = function(err) {
  console.error(err.message || err)
  process.exit(1)
}

var updated = function(date, worker, cb) {
  var first = true
  var once = function() {
    if (!first) return false
    first = false
    return true
  }

  pump(
    request('http://registry.npmjs.org/-/_view/browseUpdated?group_level=2&startkey='+encodeURIComponent(JSON.stringify([date]))),
    split(function(line) {
      if (line.indexOf('{"key":') === 0 && !once()) return JSON.parse(line.replace(/,$/, ''))
    }),
    parallel(worker),
    cb
  )
}

var prune = function(index, cb) {
  var del = []
  var deps = Object.keys(pkg.dependencies || {}).concat(Object.keys(pkg.devDependencies || {}))

  Object.keys(index.modules).forEach(function(name) {
    if (deps.indexOf(name) === -1) del.push(name)
  })

  deps.forEach(function(name) {
    var latest = (pkg.dependencies || {})[name] || (pkg.devDependencies || {})[name]
    var previous = (old.dependencies || {})[name] || (pkg.devDependencies || {})[name]
    if (latest !== previous && index.modules[name]) del.push(name)
  })

  var next = after(cb)

  del.forEach(function(name) {
    rimraf(index.modules[name], next())
  })
}

var generateIndex = function(cb) { // TODO: maybe move to module?
  var index = {dependents:{}, modules:{}}

  var readdir = function(folder, cb) {
    fs.readdir(folder, function(err, files) {
      if (err && err.code !== 'ENOENT') return cb(err)
      if (!files) files = []
      files = files.filter(function(name) {
        return name[0] !== '.'
      })
      cb(null, files)
    })
  }

  var visit = function(name, cb) {
    var list = []
    var dir = path.join(cacheModules, name)

    var deps = function(folder, cb) {
      readdir(folder, function(err, files) {
        if (err) return cb(err)
        var next = after(cb)
        files.forEach(function(name) {
          if (list.indexOf(name) === -1) list.push(name)
          deps(path.join(folder, name, 'node_modules'), next())
        })
      })
    }

    deps(path.join(dir, 'node_modules'), function(err) {
      if (err) return cb(err)
      list.forEach(function(dep) {
        if (!index.dependents[dep]) index.dependents[dep] = []
        index.dependents[dep].push(name)
      })
      index.modules[name] = dir
      cb()
    })
  }

  readdir(cacheModules, function(err, mods) {
    if (err) return cb(err)

    var next = after(function(err) {
      if (err) return cb(err)
      cb(null, index)
    })

    mods.forEach(function(mod) {
      visit(mod, next())
    })
  })
}

var install = function(cb) {
  fs.writeFile(path.join(tmp, 'README.md'), 'autogenerated by npm-buildpack', function() {
    fs.writeFile(path.join(tmp, 'package.json'), JSON.stringify(pkg, null, 2), function(err) {
      if (err) return onerror(err)
      proc.spawn('npm', ['install'], {cwd:tmp, stdio:'inherit'}).on('exit', function(code) {
        if (code) return process.exit(code)
        rimraf(localModules, function(err) {
          if (err) return onerror(err)
          ncp(cacheModules, localModules, function(err) {
            if (err) onerror(err)
          })
        })
      })
    })
  })
}

generateIndex(function(err, index) {
  if (err) return onerror(err)
  prune(index, function(err) {
    if (err) return onerror(err)
    updated(
      old.updated || new Date(Date.now() - 3600 * 48 * 1000),
      function(data, cb) {
        var key = data.key
        var name = key[1]

        pkg.updated = key[0]

        var list = [name].concat(index.dependents[name] || [])
          .map(function(m) {
            return index.modules[m]
          })
          .filter(function(m) {
            return m
          })

        var next = after(cb)
        list.forEach(function(dir) {
          rimraf(dir, next())
        })
      },
      function(err) {
        if (err) return onerror(err)
        pkg.updated = pkg.updated || old.updated
        install()
      }
    )
  })
})
